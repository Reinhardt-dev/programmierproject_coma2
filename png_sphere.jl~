#=
png_sphere:
- Julia version: 
- Author: timo
- Date: 2021-06-22
=#
function abbild(p::Tuple)
    #=
    Pr√ºfe ob Gerade, die durch Ursprung und p geht, die Bildebene schneidet.
    Return x und y Koordinaten, wenn ja, ansonsten nothing.
    =#
    x = p[1]
    y = p[2]
    z = p[3]

    if z < 250
        return nothing
    end

    r = 250 / z
    a = r * x
    b = r * y

    if ! (-250 <= a < 250) || ! (-250 <= b < 250)
        return nothing
    end
    return (Int64(floor(a)), Int64(floor(b)))
end


function is_visible(p::Tuple, m::Tuple, r)
    p2 = abbild(p)
    if isnothing(p2)
        return false
    end

    a = p[1]^2 + p[2]^2 + p[3]^2
    b = -2 * (p[1]*m[1] + p[2]*m[2] + p[3]*m[3])
    c = m[1]^2 + m[2]^2 + m[3]^2 - r^2

    s = b^2 - 4*a*c
    if s <= 0
        return true
    else
        d = sqrt(s)
        z_1, z_2 = (-b - d) / 2*a, (-b +d) / 2*a
        d_z1 = abs(p[3] - z_1)
        d_z2 = abs(p[3] - z_2)
        if d_z1 <= d_z2
             z = d_z1
        else
            z = d_z2
        end
        if z < m[3]
            return false
        else
            return true
        end
    end
end


function spherical_coordinates(x::Int, y::Int, b::Int, h::Int, m::Tuple, r::Float64)
    # h und b getauscht, siehe WhatsApp Gruppe.
    theta = (x + rand()) / b * pi
    phi = (y + rand()) / h  * 2 * pi

    x_1 = m[1] + r * sin(theta) * cos(phi)
    y_1 = m[2] + r * sin(theta) * sin(phi)
    z_1 = m[3] + r * cos(theta)

    return (x_1, y_1, z_1)
end


function samples(x::Int, y::Int, b::Int, h::Int, m::Tuple, r::Float64, dichte::Int)
    punkte = Array{Tuple{Float64, Float64, Float64}}(undef, dichte)
    for i = 1:1:dichte
        punkte[i] = spherical_coordinates(x, y, b, h, m, r)
    end
    return punkte
end


function snapshot_sphere(b::Int64, h::Int64, daten::Array, m::Tuple, r::Float64, dichte::Int64)
    # Force b, h and dichte to be Int of system because calculation on 32 bit system with Int64
    # would be inefficient. (Python int is always Int64)
    # Int uses system prefered Int (Int32 on 32 bit and Int64 on 64 bit).
    b = Int(b)
    h = Int(h)
    dichte = Int(dichte)

    # List of Pixels to Matrix h x b.
    daten = reshape(daten, (h, b))

    # Initialize Bildebene as 500 x 500 Matrix with nothing entries.
    Bildebene = fill((171, 183, 183, 255), (500, 500))

    X_MIN = - Int(ceil(b / 2))
#     X_MAX = X_MIN + b - 1
    Y_MIN = - Int(ceil(h / 2))
    Y_MAX = Y_MIN + h - 1

    c = 0

    # Loop over all pixel calculate the x- and y-coordinates.
    for i = 1:1:h
        for j = 1:1:b

            # x = X_MIN + (j-1)
            # y = Y_MAX - (i-1)
            x = j - 1
            y = i - 1

            punkte = samples(x, y, b, h, m, r, dichte)

            for p in punkte
                if is_visible(p, m, r)
                    c = c + 1
                    p_ = abbild(p)
                    Bildebene[ (-1) * p_[2] + 250, (-1) * p_[1] + 250] = daten[i, j]
                end
            end
        end
    end
    println(c)
    return reshape(Bildebene, (1, 500^2))
end


# p = (-4.454277581618312, -4.454277581618312, -97.76415534555181)
# a = abbild(p)
# println(a)

# p = (500, 500, 500)
# println(p[1])
# a = abbild(p)
# println(a)
# snapshot_sphere(100, 100, 1, 1, 1, 1)
# a = [1, 2, 3]
# snapshot_sphere(100, 100, a, (1, 1, 1), 1.0, 1)